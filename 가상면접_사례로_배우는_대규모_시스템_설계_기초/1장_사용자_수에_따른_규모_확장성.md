# 사용자 수에 따른 규모 확장성

keyword: 서버증설, 로드밸런서, 데이터베이스 다중화
추가로 공부해보면 좋을: 다중 마스터, 원형 다중화

## 수직적 규모 확장 vs 수평적 규모 확장

### 수직적 규모 확장

- 스케일 업 (Sacle up)
- 서버에 고사양 자원을 추가하는 행위


### 수평적 규모 확장

- 더 많은 서버를 추가하여 성능을 개선하는 행위

### 뭐가 더 좋은 선택일까?

트래픽의 양이 적은 편인것이 변하지 않는 사실이라면 수직적 규모 확장이 좋은 선택일 수 있다.

하지만, 수직적 규모 확장에는 한계가 있다.
- 한 대의 서버에 CPU나 메모리를 무한대로 증설할 수는 없다.
- 장애에 대한 자동 복구(failover) 방안이나 다중화(re-dundancy) 방안을 제시하지 않는다. 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다.

그래서 대부분은 **수평적 규모 확장**이 적절하다.

## 로드밸런서

수평적 규모 확장을 기본으로 한 로르밸런서를 알아보자.

- 부하 분산 집합 (load balancing set)에 속한 웹 서버 들에게 트래픽 **부하를 고르게 분산**하는 역할
- 외부에서 접근은 공개 IP 주소(public IP Address)
- 로드밸런서는 내부적으로 사설 IP 주소(private IP Address)를 이용
- 장애 자동 복구 문제 해결, 웹 계층의 가용성 향상
	- 서버 하나가 다운되면 살아있는 서버들에 분산 -> 서버 전체가 다운되는 일 방지
	- 트래픽의 가파른 증가 -> 서버 증설로 트래픽 분산

웹 계층의 트래픽 해결.


## 데이터베이스 다중화

위키피디아
> "많은 데이터베이스 관리 시스템이 다중화를 지원한다. 보통 서버 사이에 master-slave 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다."

- 쓰기 연산은 master에만 지원
- slave는 master로 부터 사본을 전달받고 읽기 연산만 지원
- 대부분의 어플리케이션은 읽기 연산의 비중이 훨씬 높다.
- 통상적으로는 slave 수가 많다.

### 데이터베이스 다중화의 장점

- 더 나은 성능
	- 읽기와 쓰기 트래픽 분산. 병렬로 처리가 가능해지기 때문에 성능이 좋아짐
- 안전성 (reliability)
	- 물리적으로 파괴 되어도 데이터 보존. 지역적으로 떨어진 여러 장소에 다중화하기 때문.
- 가용성 (availability)
	- 데이터를 여려지역에 복제. 장애가 발생하면 다른 서버에서 가져와 서비스 할 수 있음.

주 데이터베이스가 다운되면? -> 살아있는 slave 데이터베이스가 주 데이터베이스로 대체
실무에서는 더 복잡한 상황인 경우가 많다. 부 데이터베이스의 상태가 최신이 아닐 수 있다.
-> 복구 스크립트(recovery script)를 실행하여 추가한다.
-> 다중마스터 or 원형 다중화 방식을 도입하면 도움이 될 수 있다. 따로 공부해보면 좋을 부분


## 캐시

연산비용이 큰 데이터를 메모리에 두고 요청이 보다 빨리 처리될 수 있도록 하는 저장소

애플리케이션의 성능으 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우한다.
캐시는 그런 문제를 완화히줌

### 캐시 계층

읽기 주도형 캐시 전략(read-through caching strateagy)

- 캐시를 확인하고 없으면 데이터베이스에서 찾아와 캐시에 저장하고 반환


### 캐시 사용 주의사항

- 어떤상황?
	- 갱신보다 참조가 많은 상황에 적합
- 어떤 데이터?
	- 데이터를 휘발성 메모리에 둔다. 영구적 보관 데이터는 바람직하지 않음.
- 데이터 만료?
	- 만료 정책이 없으면 데이터가 메모리에 계속 남아있다.
	- 너무 짧으면 성능상 이점이 작아질 것이고 길어지면 원본과 차이가 날 가능성이 있다.
- 일관성 유지?
	- 일관성: 원본과 캐시 데이터가 동일한지
	- 관련 논문 [`<Scaling Memcache at Facebook>`](https://nymets.medium.com/%EB%B2%88%EC%97%AD-scaling-memcache-at-facebook-9c67f9e61282)
- 장애 대처?
	- 캐시 서버가 한대 -> 단일 장애 지점(Single Point of Failure, SPOF)이 되어버릴 가능성이 높음
	- 단일 장애 지점(Single Point of Failure, SPOF): 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버리는 경우
	- 여러 지역에 걸쳐 캐시서버를 분산해야한다.
- 캐시 메모리 크기?
	- 메모리가 너무 작으면, 너무 자주 캐시에 밀려나버려 캐시의 성능이 떨어진다.
	- 해결 : 캐시 메모리를 과할당(overprovision) 한다.
- 캐시 방출 정책은 무엇인가?
	- 캐시가 꽉찼을 때 추가로 캐시에 데이터를 넣어야 할 경우 기존 데이터를 내보내야 한다.
	- 널리쓰이는 방식 LRU
	- 다른정책 LFU, FIFO..

## 콘텐츠 전송 네트워크 (CDN)

정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크
이미지, 비디오, CSS, Javascript 파일 등을 캐시할 수 있다.

요청 경로(request path), 질의 문자열(query string), 쿠키, 요청 헤더 등을 정보에 기반하여 HTTML 페이지를 캐시

요청과 가장 가까운 CDN에서 정적 콘텐츠 전달. 없으면 원본 서버(웹서버, S3..)에서 가져온다.
(캐시 개념)
파일의 TTL 값으로 유효시간 관리

### 고려사항

- 비용: 보통 third-party에 의해 관리되고 데이터 전송 양에 따라 요금이 발생함. 때문에 불필요한 파일은 캐싱하지 않도록 전략을 세워야하겠다.
- 적절한 만료시간 설정
- CDN 장애에 대한 대처 방안
- 콘텐츠 무효화

> 개인적인 의견으로는 글로벌 서비스가 아니면 CDN은 오버엔지니어링이 아닐까 하는 생각이 든다. 넷플릭스 처럼 요청이 오는 지리적 거리가 다양한 경우에 훨씬 유리하게 사용되지 않을까 싶다. 내수 서비스인 경우엔 좀 더 보수적으로 생각해봐도 좋을 것 같다.

## 무상태 웹 계층

서버를 수평적 확장할 경우 서버에 상태를 보관하게 되면 난감해질 수 있다.

예를들어 서버가 1,2,3 의 이름으로 존재하고 사용자 A,B,C 가 있다고 가정해보자.
각 서버가 사용자들의 로그인 세션을 1-A, 2-B, 3-C 이렇게 가지고 있다고 가정해보자.
그럼 A 사용자의 요청은 무조건 1번 서버로 도착해야 로그인이 유효해진다.
이를 컨트롤 할 수 있는 방법은 대부분의 로드밸런서가 지원하는 `고정 세션(Sticky session)` 이라는 기능을 사용하면 된다.
하지만, 이는 로드밸런서에 부담이 많이 가는 기능이다.
게다가 로드밸런서 뒷단에 서버를 추가하거나 제거하기도 까다로워 진다. 이들 서버의 장애처리도 복잡해진다.

### 무상태 아키텍처

상태가 필요한 경우, 상태 공유 저장소를 별도로 두는 것이 좋겠다.
웹서버와 물리적으로 분리되어 있으면 단순하고, 안정적이고, 규모 확장이 쉽다.

Memcached/Redis 같은 캐시시스템 이거나, NoSQL 일 수도 있다.
책에서는 NoSQL은 규모 확장이 간편하다고 한다.

## 데이터 센터

가장 가까운 데이터 센터로 안내 = `지리적 라우팅(geoDNS-routing)`

하나가 심각한 장애가 발생하면? -> 장애가 없는 데이터 센터로 전송

### 기술적 난제

- 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 방법 고민 필요
- 데이터 동기화: 센터마다 다른 데이터베이스를 사용한다면 트래픽이 다른 데이터베이스로 우회된다고 해도 해당 데이터 센터에는 찾는 데이터가 없을 수 있다. (11장 참고)
- 테스트와 우회: 각 데이터센터별로 테스트 해보는 것도 중요. 자동화 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는데 중요한 역할

## 메시지 큐

메시지의 무손실 보장
: 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다.

서비스 또는 서버 간 결합이 느슨해진다.

## 로그, 메트릭 그리고 자동화

## 데이터베이스의 규모 확장

### 수직적 확장

2013년 스택오버플로우는 수직적 확장으로 한해간 천만명의 사용자를 처리했다.

하지만,
- 비용이 많이든다.
- SPOF(Single Point of Failure)로 인한 위험성이 크다.
- 증설의 한계가 있다.

### 수평적 확장

**샤딩**

샤딩되는 데이터베이스는 저장데이터의 중복이 없도록 한다.

샤딩 전략에 따라 샤딩키를 어떻게 정하느냐가 중요한 포인트이다.

### 풀어야 할 문제

**데이터베이스의 재 샤딩**

데이터를 다시 샤딩해야 할 경우도 있다.

1. 데이터가 너무많아져서 하나의 샤드로는 감당하기 어려울 때
2. 샤드간 데이터 불균형으로 (샤드 소진)

(5장 안정 해시 기법을 활용하면 이 문제를 해결할 수 있다.)

**유명인사(celebrity) 문제**

특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제.
트래픽이 큰 데이터가 하나의 샤드에 집중되어있다고 가정해보면 read 연산때문에 과부하 걸릴 수 있다.
각각 하나의 샤드를 할당 할 수 도 있고 더 잘게 쪼개거나 해야한다.


**조인과 비정규화**

데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 한다.

## 백만 사용자, 그리고 그 이상

수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 ㅏㅎ